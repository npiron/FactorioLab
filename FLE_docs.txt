================================================================================
Welcome to Factorio Learning Environment’s documentation! — Factorio Learning Environment 0.3.0 documentation
https://jackhopkins.github.io/factorio-learning-environment/sphinx/build/html/
================================================================================

Welcome to Factorio Learning Environment’s documentation!

An open source framework for developing and evaluating LLM agents in the game of Factorio.
Getting Started
Installation
Prerequisites
Installation Methods
Client-side Setup (Optional)
API Key Configuration
Initial Setup
Verification
Next Steps
Quickstart
CLI Commands
Basic Usage Example
Understanding the REPL Pattern
Listing Available Environments
Creating Different Environments
Complete Workflow Example
Next Steps
Troubleshooting
Common Issues
Testing Your Installation
Getting Help
Debugging Tips
Environment
Environment Overview
The REPL Pattern
Available Tools
The Namespace
Observations
Error Handling
Custom Functions and Classes
Action Space
Observation Space
Environment Methods
Architecture
Task Types
Next Steps
Gym Environment Registry
Overview
Features
Quick Start
Available Environments
Command-Line Tools
Environment Interface
API Reference
Complete Example
Error Handling
Troubleshooting
Testing
Tools
Tools Overview
What are Tools?
Tool Architecture
Anatomy of a Tool
Tool Categories
Using Tools
Return Values
Error Handling
Next Steps
Core Tools Reference
Inventory Management
Entity Manipulation
Resource Operations
Connections
Crafting & Research
Movement & Utility
Output
Best Practices
Next Steps
Creating Custom Tools
Overview
Tool Structure
Step-by-Step Guide
Complete Example
Automatic Registration
Tips & Best Practices
Common Patterns
Next Steps
Advanced Topics
Model Context Protocol (MCP)
Overview
What is MCP?
Benefits
Installation
Configuration
Using MCP
Integration with LLM Clients
Tool Definitions
Advanced Usage
Architecture
Documentation
Troubleshooting
Next Steps
Sprites
Overview
Why Use Sprites?
Installation
Default Locations
CLI Usage
Programmatic Usage
Visual Observations
Sprite Categories
Performance Considerations
Advanced Usage
Integration with Vision Models
Troubleshooting
Next Steps
Database Configuration
Overview
Supported Databases
SQLite Configuration
PostgreSQL Configuration
Database Schema
Using the Database
Database Client API
Migration
Backup and Restore
Performance Optimization
Troubleshooting
Best Practices
Next Steps
Reference
Project Structure
Indices and tables

Index
Module Index
Search Page

================================================================================
Installation — Factorio Learning Environment 0.3.0 documentation
https://jackhopkins.github.io/factorio-learning-environment/sphinx/build/html/getting_started/installation.html
================================================================================

Installation

Prerequisites

Before installing FLE, ensure you have:
Docker
: Required for running Factorio server instances
Python 3.10+
: The minimum Python version supported
Factorio
(version 1.1.110): Only needed for optional rendering with graphics
Installation Methods

Core Installation

Install the core FLE SDK package:
# Using pip
pip
install
factorio-learning-environment
# Using uv (recommended)
uv
add
factorio-learning-environment
Installation with Optional Features

FLE provides several optional feature sets:
# For running experiments
pip
install
factorio-learning-environment
[
eval
]
# For MCP protocol support
pip
install
factorio-learning-environment
[
mcp
]
# For PostgreSQL support
pip
install
factorio-learning-environment
[
psql
]
# Install all features
pip
install
factorio-learning-environment
[
eval,mcp,psql
]
# Using uv (recommended)
uv
add
factorio-learning-environment
[
eval
]
Client-side Setup (Optional)

For rendering Factorio with graphics, you need to set up a Factorio client:
Purchase and Install Factorio
Purchase from the
official website
(recommended) or on Steam
Download and install the game
Downgrade to Version 1.1.110
Steam
: Right-click Factorio → Properties → Betas → Select
1.1.110
Important
: Uncheck the Space Age DLC if you have it, as it forces the 2.x branch
Activate Server License
Open the Factorio client
Navigate to
Multiplayer
Connect to
localhost:34197
(default) or your configured address in Docker
Once connected, you can safely disconnect. This step confirms your Factorio license with the server.
API Key Configuration

FLE supports multiple LLM providers for agent evaluation.
Quick Setup (Recommended)

Use the interactive setup script:
python
fle/eval/infra/setup_api_keys.py
This script helps you:
Configure API keys for OpenAI, Anthropic, and other providers
Set up API key rotation for high-volume experiments
Generate provider-specific configuration files
Validate your API key setup
Manual Setup

Add your API keys to the
.env
file:
# OpenAI
OPENAI_API_KEY
=
sk-...
# Anthropic
ANTHROPIC_API_KEY
=
sk-ant-...
# Additional providers as needed
Advanced Configuration

For large-scale experiments, you can set up API key rotation and provider-specific settings using the configuration files generated by
setup_api_keys.py
.
Initial Setup

When you run
fle
init
or
fle
eval
for the first time:
An
.env
file is automatically created
A
configs/
directory with example configurations is created
Verification

Verify your installation by starting the Factorio cluster:
# Start Factorio cluster
fle
cluster
start
# Run evaluation trajectories (requires [eval] dependencies)
fle
eval
--config
configs/gym_run_config.json
Next Steps

Continue to
Quickstart
to learn how to use FLE
See
Troubleshooting
if you encounter issues

================================================================================
Quickstart — Factorio Learning Environment 0.3.0 documentation
https://jackhopkins.github.io/factorio-learning-environment/sphinx/build/html/getting_started/quickstart.html
================================================================================

Quickstart

This guide will get you up and running with FLE in minutes.
CLI Commands

Starting the Factorio Cluster

# Start Factorio cluster
fle
cluster
start
Running Evaluations

# Run evaluation trajectories (requires [eval] dependencies)
fle
eval
--config
configs/gym_run_config.json
Note
When you run
fle
init
or
fle
eval
for the first time, an
.env
file and a
configs/
directory with example configurations are created automatically.
Basic Usage Example

Here’s a complete example demonstrating how to use FLE with the Gym interface:
import
gym
from
fle.env.gym_env.action
import
Action
# Create an environment
env
=
gym
.
make
(
"iron_ore_throughput"
)
# Reset the environment
obs
=
env
.
reset
(
options
=
{
'game_state'
:
None
})
# Take an action
action
=
Action
(
agent_idx
=
0
,
# Which agent takes the action
code
=
'print("Hello Factorio!")'
,
# Python code to execute
game_state
=
None
# Optional: game state to reset to before running code
)
# Execute the action
obs
,
reward
,
terminated
,
truncated
,
info
=
env
.
step
(
action
)
# Clean up
env
.
close
()
Understanding the REPL Pattern

Agents interact with FLE through a
REPL
(Read-Eval-Print-Loop) pattern:
Observation
: The agent observes the world through the output streams (stderr/stdout) of their last program
Action
: The agent generates a Python program to perform their desired action
Feedback
: The environment executes the program and provides an output stream
Example Action-Feedback Cycle

Action:
# 1. Get iron patch and place mining drill
drill
=
place_entity
(
entity
=
Prototype
.
MiningDrill
,
position
=
nearest
(
Resource
.
IronOre
),
direction
=
Direction
.
NORTH
)
# 2. Add output storage
chest
=
place_entity_next_to
(
entity
=
Prototype
.
IronChest
,
reference_position
=
drill
.
drop_position
,
direction
=
Direction
.
SOUTH
)
# 3. Verify automation chain and observe entities
sleep
(
10
)
# Sleep for 10 seconds
assert
drill
.
status
==
EntityStatus
.
WORKING
print
(
get_entities
())
Feedback:
>>>
[
BurnerMiningDrill
(
fuel
=
Inventory
({
'coal'
:
4
}),
>>>
name
=
'burner-mining-drill'
,
>>>
direction
=
Direction
.
DOWN
,
>>>
position
=
Position
(
x
=-
28.0
,
y
=-
61.0
),
>>>
energy
=
2666.6666666667
,
>>>
tile_dimensions
=
TileDimensions
(
tile_width
=
2.0
,
tile_height
=
2.0
),
>>>
status
=
EntityStatus
.
WORKING
,
>>>
neighbours
=
[
Entity
(
name
=
'iron-chest'
,
direction
=
DOWN
,
position
=
Position
(
x
=-
27.5
y
=-
59.5
)],
>>>
drop_position
=
Position
(
x
=-
27.5
,
y
=-
59.5
),
>>>
resources
=
[
Ingredient
(
name
=
'iron-ore'
,
count
=
30000
,
type
=
None
)]),
>>>
Chest
(
name
=
'iron-chest'
,
>>>
direction
=
Direction
.
UP
,
>>>
position
=
Position
(
x
=-
27.5
,
y
=-
59.5
),
>>>
energy
=
0.0
,
>>>
tile_dimensions
=
TileDimensions
(
tile_width
=
1.0
,
tile_height
=
1.0
),
>>>
status
=
EntityStatus
.
NORMAL
,
>>>
inventory
=
Inventory
({
'iron-ore'
:
75
}))]
Listing Available Environments

from
fle.env.gym_env.registry
import
list_available_environments
# Get all available environment IDs
env_ids
=
list_available_environments
()
print
(
f
"Available environments:
{
env_ids
}
"
)
Or use the command-line tool:
python
fle/env/gym_env/example_usage.py
--list
Creating Different Environments

import
gym
# Create throughput environments
env
=
gym
.
make
(
"iron_plate_throughput"
)
env
=
gym
.
make
(
"automation_science_pack_throughput"
)
env
=
gym
.
make
(
"crude_oil_throughput"
)
# Create open play environment
env
=
gym
.
make
(
"open_play"
)
Complete Workflow Example

Here’s a complete example demonstrating the full workflow:
import
gym
from
fle.env.gym_env.registry
import
list_available_environments
,
get_environment_info
from
fle.env.gym_env.action
import
Action
# 1. List available environments
env_ids
=
list_available_environments
()
print
(
f
"Found
{
len
(
env_ids
)
}
environments"
)
# 2. Get information about a specific environment
info
=
get_environment_info
(
"iron_ore_throughput"
)
print
(
f
"Description:
{
info
[
'description'
]
}
"
)
# 3. Create the environment
env
=
gym
.
make
(
"iron_ore_throughput"
)
# 4. Use the environment
obs
=
env
.
reset
(
options
=
{
'game_state'
:
None
})
print
(
f
"Initial observation keys:
{
list
(
obs
.
keys
())
}
"
)
# 5. Take actions
current_state
=
None
for
step
in
range
(
5
):
action
=
Action
(
agent_idx
=
0
,
game_state
=
current_state
,
code
=
f
'print("Step
{
step
}
: Hello Factorio!")'
)
obs
,
reward
,
terminated
,
truncated
,
info
=
env
.
step
(
action
)
done
=
terminated
or
truncated
current_state
=
info
[
'output_game_state'
]
print
(
f
"Step
{
step
}
: Reward=
{
reward
}
, Done=
{
done
}
"
)
if
done
:
break
# 6. Clean up
env
.
close
()
Next Steps

Learn about the
Environment Overview
and how agents interact with it
Explore the
Tools Overview
available to agents
Check out the
Gym Environment Registry
for available tasks

================================================================================
Troubleshooting — Factorio Learning Environment 0.3.0 documentation
https://jackhopkins.github.io/factorio-learning-environment/sphinx/build/html/getting_started/troubleshooting.html
================================================================================

Troubleshooting

This page addresses common issues you may encounter when using FLE.
Common Issues

“No valid programs found for version X”

Symptom
: You see this message during initialization.
Solution
: This is normal during initialization. The system will start generating programs shortly. No action needed.
Database Connection Errors

Symptom
: Errors connecting to the database when running evaluations.
Solution
:
Verify your database configuration in the
.env
file
Ensure the database exists
For SQLite: Check that the directory for the database file exists
For PostgreSQL: Verify the database server is running
API Key Errors

Symptom
: Authentication errors when running agent evaluations.
Solution
:
Run the API key setup script:
python
fle/eval/infra/setup_api_keys.py
Verify your API keys are correctly set in the
.env
file
Check that you’re using the correct provider (OpenAI, Anthropic, etc.)
Docker Issues

Symptom
: Permission denied or Docker connection errors.
Solution
:
Ensure Docker is installed and running
Verify your user has permission to run Docker without sudo:
sudo
usermod
-aG
docker
$USER
Log out and log back in for the group change to take effect
Test Docker access:
docker
ps
Connection Issues

Symptom
: Cannot connect to Factorio server.
Solution
:
Make sure the Factorio server is running:
fle
cluster
start
Check that ports are properly configured
Verify Docker containers are running:
docker
ps
Check Docker logs for errors:
docker
logs
<container_id>
Environment Creation Fails

Symptom
:
gym.make()
fails with connection errors.
Solution
:
Ensure Factorio containers are running
Check that the cluster setup is working
Verify network connectivity
No Environments Found

Symptom
:
list_available_environments()
returns an empty list.
Solution
:
Check that the task definitions directory exists
Verify JSON files in
fle/eval/tasks/task_definitions/
are valid
Check file permissions
Ensure you’re running from the correct directory
Import Errors

Symptom
:
ModuleNotFoundError
or import errors.
Solution
:
Ensure you’re running from the correct directory
Check that all dependencies are installed:
pip
install
factorio-learning-environment
[
eval
]
Verify the Python path includes the project root
Try reinstalling the package:
pip
install
--force-reinstall
factorio-learning-environment
Space Age DLC Issues

Symptom
: Factorio client is on version 2.x instead of 1.1.110.
Solution
:
Open Steam library
Right-click Factorio → Properties
Navigate to DLC section
Uncheck Space Age DLC
(this forces the 2.x branch)
Go to Betas tab
Select version
1.1.110
Testing Your Installation

Run the test suite to verify everything is working:
# Test the gym registry
python
fle/env/tests/gym_env/test_registry.py
# List available environments
python
fle/env/gym_env/example_usage.py
--list
# Run with detailed output
python
fle/env/gym_env/example_usage.py
--detail
Getting Help

If you continue to experience issues:
Check the
GitHub Issues
Join the
Discord (#factorio-learning-env)
Review the
Project Structure
to understand the codebase layout
Debugging Tips

Enable Verbose Logging

Set environment variables for more detailed output:
export
FLE_LOG_LEVEL
=
DEBUG
Check Docker Logs

View logs from Factorio containers:
# List running containers
docker
ps
# View logs for a specific container
docker
logs
<container_id>
# Follow logs in real-time
docker
logs
-f
<container_id>
Verify Environment Variables

Check that your
.env
file is properly loaded:
import
os
from
dotenv
import
load_dotenv
load_dotenv
()
print
(
os
.
getenv
(
'OPENAI_API_KEY'
))
# Should show your API key (masked)
print
(
os
.
getenv
(
'FLE_DB_TYPE'
))
# Should show sqlite or postgres

================================================================================
Environment Overview — Factorio Learning Environment 0.3.0 documentation
https://jackhopkins.github.io/factorio-learning-environment/sphinx/build/html/environment/overview.html
================================================================================

Environment Overview

FLE is an agent evaluation environment built on the game of Factorio, a popular resource management simulation game.
The REPL Pattern

Agents interact with FLE through code synthesis using a
REPL
(Read-Eval-Print-Loop) pattern:
Observation
: The agent observes the world through the output streams (stderr/stdout) of their last program
Action
: The agent generates a Python program to perform their desired action
Feedback
: The environment executes the program, assigns variables, adds classes/functions to the namespace, and provides an output stream
Example Interaction

Action:
# 1. Get iron patch and place mining drill
drill
=
place_entity
(
entity
=
Prototype
.
MiningDrill
,
position
=
nearest
(
Resource
.
IronOre
),
direction
=
Direction
.
NORTH
)
# 2. Add output storage
chest
=
place_entity_next_to
(
entity
=
Prototype
.
IronChest
,
reference_position
=
drill
.
drop_position
,
direction
=
Direction
.
SOUTH
)
# 3. Verify automation chain and observe entities
sleep
(
10
)
# Sleep for 10 seconds
assert
drill
.
status
==
EntityStatus
.
WORKING
print
(
get_entities
())
Feedback:
>>>
[
BurnerMiningDrill
(
fuel
=
Inventory
({
'coal'
:
4
}),
>>>
name
=
'burner-mining-drill'
,
>>>
direction
=
Direction
.
DOWN
,
>>>
position
=
Position
(
x
=-
28.0
,
y
=-
61.0
),
>>>
energy
=
2666.6666666667
,
>>>
tile_dimensions
=
TileDimensions
(
tile_width
=
2.0
,
tile_height
=
2.0
),
>>>
status
=
EntityStatus
.
WORKING
,
>>>
neighbours
=
[
Entity
(
name
=
'iron-chest'
,
direction
=
DOWN
,
position
=
Position
(
x
=-
27.5
y
=-
59.5
)],
>>>
drop_position
=
Position
(
x
=-
27.5
,
y
=-
59.5
),
>>>
resources
=
[
Ingredient
(
name
=
'iron-ore'
,
count
=
30000
,
type
=
None
)]),
>>>
Chest
(
name
=
'iron-chest'
,
>>>
direction
=
Direction
.
UP
,
>>>
position
=
Position
(
x
=-
27.5
,
y
=-
59.5
),
>>>
energy
=
0.0
,
>>>
tile_dimensions
=
TileDimensions
(
tile_width
=
1.0
,
tile_height
=
1.0
),
>>>
status
=
EntityStatus
.
NORMAL
,
>>>
inventory
=
Inventory
({
'iron-ore'
:
75
}))]
Available Tools

Agents are provided with the Python standard library and an API comprising
Tools Overview
that they can use.
Tools
are functions that:
Perform a game action
Return a typed object (e.g. an
Inventory
)
Can be stored as a named
variable
in the Python namespace for later use
The Namespace

The namespace acts as an
episodic symbolic memory system
. Saved objects represent an observation of the environment at the moment of query.
This enables agents to:
Maintain complex state representations
Build hierarchical abstractions as factories scale
Reference previous observations and computations
Observations

Agents observe
stdout
and
stderr
- the output streams of their program.
Agents may intentionally:
Print relevant objects to construct observations
Print computations and intermediate results
Use
print()
strategically to monitor state
Error Handling

Mistakes in code or invalid operations raise typed
exceptions
with detailed context that is written to stderr.
This enables agents to:
Reactively debug
their programs after execution
Proactively use
runtime assertions during execution to self-verify actions
Learn from detailed error messages
Custom Functions and Classes

Agents can enhance their internal representation of the game state by defining:
Utility functions
for reuse throughout an episode, to encapsulate previously successful logic
Classes
in the namespace to better organize the data retrieved from the game
These definitions persist in the namespace across actions within an episode.
Action Space

The action space is defined as:
{
'agent_idx'
:
Discrete
(
instance
.
num_agents
),
# Index of the agent taking the action
'game_state'
:
Text
(
max_length
=
1000000
),
# Optional: game state to reset to
'code'
:
Text
(
max_length
=
10000
)
# Python code to execute
}
Observation Space

The observation space includes:
raw_text
: Output from the last action
entities
: List of entities on the map
inventory
: Current inventory state
research
: Research progress and technologies
game_info
: Game state (tick, time, speed)
score
: Current score
flows
: Production statistics
task_verification
: Task completion status
messages
: Inter-agent messages (for multi-agent scenarios)
serialized_functions
: Available functions
task_info
: Information about the task
map_image
: Base64 encoded PNG image
Environment Methods

Standard Gym Interface

All FLE environments follow the standard OpenAI Gym interface:
# Reset the environment
obs
=
env
.
reset
(
options
:
Dict
[
str
,
Any
],
seed
:
Optional
[
int
]
=
None
)
->
Dict
[
str
,
Any
]
# Take a step
obs
,
reward
,
terminated
,
truncated
,
info
=
env
.
step
(
action
:
Action
)
# Clean up
env
.
close
()
Architecture

┌─────────────────┐
│     Agent       │
│ (Synthesizes    │
│  Python Code)   │
└────────┬────────┘
         │
         ▼
┌─────────────────────────────┐
│  Learning Environment       │
│  ┌─────────────────────┐   │
│  │   Interpreter       │   │
│  │   - Executes code   │   │
│  │   - Manages         │   │
│  │     namespace       │   │
│  └──────┬──────────────┘   │
│         │                   │
│  ┌──────▼──────────────┐   │
│  │   client.py         │   │
│  │   (Tool Interface)  │   │
│  └──────┬──────────────┘   │
└─────────┼──────────────────┘
          │ Remote TCP Call
          ▼
┌─────────────────────────────┐
│   Factorio Server           │
│  ┌─────────────────────┐   │
│  │   server.lua        │   │
│  │   (Game Logic)      │   │
│  └──────┬──────────────┘   │
│         │                   │
│  ┌──────▼──────────────┐   │
│  │  Factorio Engine    │   │
│  │  (Game Simulation)  │   │
│  └─────────────────────┘   │
└─────────────────────────────┘
Task Types

FLE provides two main evaluation settings:
Lab-Play

24 structured tasks with fixed resources, testing specific capabilities:
Circuits
: Advanced circuits, electronic circuits, processing units
Science Packs
: Automation, logistics, chemical, military, production, utility
Components
: Batteries, engines, inserters, gears, low density structures
Raw Materials
: Iron ore, iron plates, steel plates, plastic bars
Oil & Chemicals
: Crude oil, petroleum gas, sulfuric acid, sulfur
Military
: Piercing rounds, stone walls
Most tasks require 16 items per 60 seconds; fluid tasks require 250 units per 60 seconds.
Open-Play

An unbounded task of building the largest possible factory on a procedurally generated map. This tests:
Long-term planning
Resource optimization
Scaling strategies
Error recovery
Next Steps

Explore the
Gym Environment Registry
to see all available tasks
Learn about
Tools Overview
available to agents
See
Quickstart
for usage examples

================================================================================
Gym Environment Registry — Factorio Learning Environment 0.3.0 documentation
https://jackhopkins.github.io/factorio-learning-environment/sphinx/build/html/environment/gym_registry.html
================================================================================

Gym Environment Registry

The Factorio Learning Environment uses a gym environment registry to automatically discover and register all available tasks. This allows you to use
gym.make()
to create environments and reference them by their environment IDs.
Overview

The registry system automatically discovers all task definitions in
fle/eval/tasks/task_definitions/
and registers them as gym environments. This means you can create any Factorio environment using the familiar
gym.make()
pattern.
Features

Automatic Discovery
: Automatically discovers all task definitions in
fle/eval/tasks/task_definitions/
Gym Integration
: All environments are registered with
gym
and can be created using
gym.make()
Task Metadata
: Provides access to task descriptions, configurations, and metadata
Multi-agent Support
: Supports both single-agent and multi-agent environments
Command-line Tools
: Built-in tools for exploring and testing environments
Quick Start

1. List Available Environments

from
fle.env.gym_env.registry
import
list_available_environments
# Get all available environment IDs
env_ids
=
list_available_environments
()
print
(
f
"Available environments:
{
env_ids
}
"
)
Or use the command-line tool:
python
fle/env/gym_env/example_usage.py
--list
2. Create an Environment

import
gym
# Create any available environment
env
=
gym
.
make
(
"iron_ore_throughput"
)
3. Use the Environment

from
fle.env.gym_env.action
import
Action
# Reset the environment
obs
=
env
.
reset
(
options
=
{
'game_state'
:
None
})
# Take an action
action
=
Action
(
agent_idx
=
0
,
# Which agent takes the action
code
=
'print("Hello Factorio!")'
,
# Python code to execute
game_state
=
None
# Optional: game state to reset to before running code
)
# Execute the action
obs
,
reward
,
terminated
,
truncated
,
info
=
env
.
step
(
action
)
# Clean up
env
.
close
()
Available Environments

Throughput Tasks (Lab Play)

All throughput tasks are defined in
fle/eval/tasks/task_definitions/lab_play/throughput_tasks.py
. The 24 available tasks are:
Circuits
advanced_circuit_throughput
electronic_circuit_throughput
processing_unit_throughput
Science Packs
automation_science_pack_throughput
logistics_science_pack_throughput
chemical_science_pack_throughput
military_science_pack_throughput
production_science_pack_throughput
utility_science_pack_throughput
Components
battery_throughput
engine_unit_throughput
inserter_throughput
iron_gear_wheel_throughput
low_density_structure_throughput
Raw Materials
iron_ore_throughput
iron_plate_throughput
steel_plate_throughput
plastic_bar_throughput
Oil & Chemicals
crude_oil_throughput
petroleum_gas_throughput
sulfuric_acid_throughput
sulfur_throughput
Military
piercing_round_throughput
stone_wall_throughput
Note
Most tasks require 16 items per 60 seconds; fluid tasks require 250 units per 60 seconds.
Open Play Environment

open_play
- An unbounded task of building the largest possible factory
Example Usage

import
gym
# Create throughput environments
env
=
gym
.
make
(
"iron_plate_throughput"
)
env
=
gym
.
make
(
"automation_science_pack_throughput"
)
env
=
gym
.
make
(
"crude_oil_throughput"
)
# Create open play environment
env
=
gym
.
make
(
"open_play"
)
Command-Line Tools

The
example_usage.py
script provides both interactive examples and command-line tools:
# Run interactive examples
python
fle/env/gym_env/example_usage.py
# List all environments
python
fle/env/gym_env/example_usage.py
--list
# Show detailed information
python
fle/env/gym_env/example_usage.py
--detail
# Search for specific environments
python
fle/env/gym_env/example_usage.py
--search
iron
# Output in gym.make() format
python
fle/env/gym_env/example_usage.py
--gym-format
Environment Interface

Action Space

{
'agent_idx'
:
Discrete
(
instance
.
num_agents
),
# Index of the agent taking the action
'game_state'
:
Text
(
max_length
=
1000000
),
# Optional: game state to reset to
'code'
:
Text
(
max_length
=
10000
)
# Python code to execute
}
Observation Space

The observation space includes:
raw_text
: Output from the last action
entities
: List of entities on the map
inventory
: Current inventory state
research
: Research progress and technologies
game_info
: Game state (tick, time, speed)
score
: Current score
flows
: Production statistics
task_verification
: Task completion status
messages
: Inter-agent messages
serialized_functions
: Available functions
task_info
: Information about the task
map_image
: Base64 encoded PNG image
Methods

# Reset the environment
reset
(
options
:
Dict
[
str
,
Any
],
seed
:
Optional
[
int
]
=
None
)
->
Dict
[
str
,
Any
]
# Take a step
step
(
action
:
Action
)
->
Tuple
[
Dict
[
str
,
Any
],
float
,
bool
,
bool
,
Dict
[
str
,
Any
]]
# Clean up
close
()
->
None
API Reference

Registry Functions

# Returns a list of all registered environment IDs
list_available_environments
()
->
List
[
str
]
# Returns detailed information about a specific environment
get_environment_info
(
env_id
:
str
)
->
Optional
[
Dict
[
str
,
Any
]]
# Manually trigger environment discovery and registration
register_all_environments
()
->
None
Environment Creation

# Creates a Factorio gym environment
gym
.
make
(
env_id
:
str
,
**
kwargs
)
->
FactorioGymEnv
Complete Example

Here’s a complete example that demonstrates the full workflow:
import
gym
from
fle.env.gym_env.registry
import
list_available_environments
,
get_environment_info
from
fle.env.gym_env.action
import
Action
# 1. List available environments
env_ids
=
list_available_environments
()
print
(
f
"Found
{
len
(
env_ids
)
}
environments"
)
# 2. Get information about a specific environment
info
=
get_environment_info
(
"iron_ore_throughput"
)
print
(
f
"Description:
{
info
[
'description'
]
}
"
)
# 3. Create the environment
env
=
gym
.
make
(
"iron_ore_throughput"
)
# 4. Use the environment
obs
=
env
.
reset
(
options
=
{
'game_state'
:
None
})
print
(
f
"Initial observation keys:
{
list
(
obs
.
keys
())
}
"
)
# 5. Take actions
current_state
=
None
for
step
in
range
(
5
):
action
=
Action
(
agent_idx
=
0
,
game_state
=
current_state
,
code
=
f
'print("Step
{
step
}
: Hello Factorio!")'
)
obs
,
reward
,
terminated
,
truncated
,
info
=
env
.
step
(
action
)
done
=
terminated
or
truncated
current_state
=
info
[
'output_game_state'
]
print
(
f
"Step
{
step
}
: Reward=
{
reward
}
, Done=
{
done
}
"
)
if
done
:
break
# 6. Clean up
env
.
close
()
Error Handling

The registry includes error handling for:
Missing task definition files
Invalid JSON configurations
Missing Factorio containers
Environment creation failures
If an environment fails to load, a warning will be printed but the registry will continue to load other environments.
Troubleshooting

Environment Creation Fails

If
gym.make()
fails with connection errors:
Ensure Factorio containers are running
Check that the cluster setup is working
Verify network connectivity
No Environments Found

If no environments are listed:
Check that the task definitions directory exists
Verify JSON files are valid
Check file permissions
Import Errors

If you get import errors:
Ensure you’re running from the correct directory
Check that all dependencies are installed
Verify the Python path includes the project root
Testing

Run the test suite to verify the registry is working correctly:
python
fle/env/tests/gym_env/test_registry.py
This registry system provides a clean, standardized interface for working with Factorio gym environments, making it easy to experiment with different tasks and integrate with existing gym-based frameworks.

================================================================================
Tools Overview — Factorio Learning Environment 0.3.0 documentation
https://jackhopkins.github.io/factorio-learning-environment/sphinx/build/html/tools/overview.html
================================================================================

Tools Overview

Agents interact with the game using
tools
, which represent a narrow API into the game. Tools are functions that agents can call to perform actions and retrieve information.
What are Tools?

Tools
are functions that:
Perform a game action (e.g., placing an entity, crafting an item)
Return a typed object (e.g.,
Entity
,
Inventory
,
Recipe
)
Can be stored as named variables in the Python namespace for later use
Tools live in
fle/env/tools/
, and are either:
Admin tools
: Non-agent accessible, used for environment management
Agent tools
: Used by agents to interact with the game
Tool Architecture

┌─────────────────┐
│     Agent       │
│  (Synthesizes   │
│  Python Code)   │
└────────┬────────┘
         │
┌────────▼────────────────────┐
│  Learning Environment       │
│  ┌────────────────────┐    │
│  │   Interpreter      │    │
│  └─────────┬──────────┘    │
│            │                 │
│  ┌─────────▼──────────┐    │
│  │   client.py        │◄───┼─── Exceptions
│  │  (Python Interface)│    │
│  └─────────┬──────────┘    │
│            │                 │
│            │ Objects         │
└────────────┼─────────────────┘
             │
             │ Remote TCP Call
             │
┌────────────▼─────────────────┐
│   Factorio Server            │
│  ┌─────────────────────┐    │
│  │   server.lua        │    │
│  │  (Game Logic)       │    │
│  └─────────┬───────────┘    │
│            │                  │
│  ┌─────────▼───────────┐    │
│  │  Factorio Engine    │    │
│  │  (Game Simulation)  │    │
│  └─────────────────────┘    │
└──────────────────────────────┘
Anatomy of a Tool

A tool requires 3 files:
agent.md
: The agent documentation for the tool, including usage patterns, best practices, and failure modes
client.py
: The client-side implementation - a Python class that can be invoked by the agent
server.lua
: The server-side implementation - handles most of the logic and heavy lifting
Tool Categories

Tools can be grouped into several categories:
Inventory Management

inspect_inventory
: Check contents of player or entity inventories
insert_item
: Place items from player inventory into entities
extract_item
: Remove items from entity inventories
Entity Manipulation

place_entity
: Place entities in the world
place_entity_next_to
: Place entities relative to others
pickup_entity
: Remove entities from the world
rotate_entity
: Change entity orientation
get_entity
: Retrieve entity objects at positions
get_entities
: Find multiple entities in an area
Resource Operations

nearest
: Locate closest resources/entities
get_resource_patch
: Analyze resource deposits
harvest_resource
: Gather resources from the world
Connections

connect_entities
: Create connections between entities
get_connection_amount
: Calculate required connection items
Crafting & Research

craft_item
: Create items from components
get_prototype_recipe
: Retrieve crafting requirements
set_entity_recipe
: Configure machine crafting recipes
set_research
: Initiate technology research
get_research_progress
: Monitor research status
Movement & Utility

move_to
: Move player to position
nearest_buildable
: Find valid building locations
sleep
: Pause execution
launch_rocket
: Control rocket silo launches
Output

print
: Output debug information to stdout
Using Tools

Tools are called like normal Python functions within agent code:
# Find nearest iron ore
iron_position
=
nearest
(
Resource
.
IronOre
)
# Place a mining drill
drill
=
place_entity
(
entity
=
Prototype
.
MiningDrill
,
position
=
iron_position
,
direction
=
Direction
.
NORTH
)
# Check the drill's status
print
(
f
"Drill status:
{
drill
.
status
}
"
)
# Store result for later use
my_first_drill
=
drill
Return Values

Tools return typed objects that can be:
Inspected
: Access attributes like
drill.status
or
inventory.items
Stored
: Save as variables for future reference
Printed
: Display information to stdout for observation
Common Return Types

Entity
: Represents a game entity (drill, chest, inserter, etc.)
Inventory
: Contains items and quantities
Recipe
: Describes crafting requirements
Position
: X, Y coordinates
ResourcePatch
: Information about resource deposits
Error Handling

Tools raise typed exceptions with detailed context when:
Invalid parameters are provided
Required resources are unavailable
Game constraints are violated (e.g., invalid placement)
Entities don’t exist or have been destroyed
Example error:
InvalidEntityPlacementException
:
Cannot
place
burner
-
mining
-
drill
at
Position
(
x
=
10
,
y
=
20
)
-
location
is
occupied
by
iron
-
chest
Next Steps

See
Core Tools Reference
for detailed documentation on each tool
Learn how to
Creating Custom Tools
for specialized functionality
Review the
Environment Overview
to understand the full context

================================================================================
Core Tools Reference — Factorio Learning Environment 0.3.0 documentation
https://jackhopkins.github.io/factorio-learning-environment/sphinx/build/html/tools/core_tools.html
================================================================================

Core Tools Reference

This page provides a comprehensive reference for all core tools available to agents.
Inventory Management

inspect_inventory

Checks contents of player or entity inventories.
Features:
Supports various inventory types (chests, furnaces, etc.)
Returns
Inventory
object with count methods
Can query specific items
Example:
# Check player inventory
inventory
=
inspect_inventory
()
print
(
f
"Iron plates:
{
inventory
[
'iron-plate'
]
}
"
)
# Check entity inventory
chest
=
get_entity
(
Prototype
.
IronChest
,
position
)
inventory
=
inspect_inventory
(
chest
)
insert_item

Places items from player inventory into entities.
Features:
Works with machines, chests, belts
Validates item compatibility
Returns updated entity
Example:
# Insert coal into a furnace
furnace
=
get_entity
(
Prototype
.
StoneFurnace
,
furnace_position
)
insert_item
(
Prototype
.
Coal
,
furnace
,
quantity
=
10
)
extract_item

Removes items from entity inventories.
Features:
Supports all inventory types
Auto-transfers to player inventory
Returns quantity extracted
Example:
# Extract iron plates from a chest
chest
=
get_entity
(
Prototype
.
IronChest
,
chest_position
)
extracted
=
extract_item
(
Prototype
.
IronPlate
,
chest
,
quantity
=
50
)
print
(
f
"Extracted
{
extracted
}
iron plates"
)
Entity Manipulation

place_entity

Places entities in the world.
Features:
Handles direction and positioning
Validates placement requirements
Returns placed
Entity
object
Example:
# Place a mining drill
drill
=
place_entity
(
entity
=
Prototype
.
MiningDrill
,
position
=
Position
(
x
=
10
,
y
=
20
),
direction
=
Direction
.
NORTH
)
place_entity_next_to

Places entities relative to others.
Features:
Automatic spacing/alignment
Handles entity dimensions
Supports all entity types
Example:
# Place a chest next to a drill
chest
=
place_entity_next_to
(
entity
=
Prototype
.
IronChest
,
reference_position
=
drill
.
drop_position
,
direction
=
Direction
.
SOUTH
)
pickup_entity

Removes entities from the world.
Features:
Returns items to inventory
Handles entity groups
Supports all placeable items
Example:
# Pick up a mining drill
drill
=
get_entity
(
Prototype
.
BurnerMiningDrill
,
position
)
pickup_entity
(
drill
)
rotate_entity

Changes entity orientation.
Features:
Affects entity behavior (e.g., inserter direction)
Validates rotation rules
Returns updated entity
Example:
# Rotate an inserter to face a different direction
inserter
=
get_entity
(
Prototype
.
Inserter
,
position
)
rotate_entity
(
inserter
,
Direction
.
EAST
)
get_entity

Retrieves entity objects at positions.
Features:
Updates stale references
Returns typed
Entity
objects
Handles all entity types
Example:
# Get a chest at a specific position
chest
=
get_entity
(
Prototype
.
IronChest
,
Position
(
x
=
10
,
y
=
20
))
get_entities

Finds multiple entities in an area.
Features:
Supports filtering by type
Returns
List[Entity]
Groups connected entities
Example:
# Get all entities
entities
=
get_entities
()
# Get entities by type
drills
=
get_entities
(
prototype
=
Prototype
.
BurnerMiningDrill
)
Resource Operations

nearest

Locates closest resources/entities.
Features:
Finds ores, water, trees
Returns
Position
object
500 tile search radius
Example:
# Find nearest iron ore
iron_position
=
nearest
(
Resource
.
IronOre
)
# Find nearest water
water_position
=
nearest
(
Resource
.
Water
)
get_resource_patch

Analyzes resource deposits.
Features:
Returns size and boundaries
Supports all resource types
Includes total resource amount
Example:
# Get information about an iron ore patch
patch
=
get_resource_patch
(
Resource
.
IronOre
,
position
)
print
(
f
"Patch size:
{
patch
.
size
}
"
)
print
(
f
"Total iron:
{
patch
.
amount
}
"
)
harvest_resource

Gathers resources from the world.
Features:
Supports ores, trees, rocks
Auto-collects to inventory
Returns amount harvested
Example:
# Harvest iron ore manually
iron_position
=
nearest
(
Resource
.
IronOre
)
harvested
=
harvest_resource
(
iron_position
,
quantity
=
50
)
Connections

connect_entities

Creates connections between entities.
Features:
Handles belts, pipes, power
Automatic pathfinding
Returns connection group
Example:
# Connect a drill to a chest with a transport belt
connection
=
connect_entities
(
drill
.
drop_position
,
chest
.
position
,
connection_type
=
Prototype
.
TransportBelt
)
get_connection_amount

Calculates required connection items.
Features:
Pre-planning tool
Works with all connection types
Returns item count needed
Example:
# Calculate how many belts are needed
amount
=
get_connection_amount
(
start_position
=
drill
.
drop_position
,
end_position
=
chest
.
position
,
connection_type
=
Prototype
.
TransportBelt
)
print
(
f
"Need
{
amount
}
belts"
)
Crafting & Research

craft_item

Creates items from components.
Features:
Handles recursive crafting
Validates technology requirements
Returns crafted amount
Example:
# Craft 10 iron gear wheels
crafted
=
craft_item
(
Prototype
.
IronGearWheel
,
quantity
=
10
)
get_prototype_recipe

Retrieves crafting requirements.
Features:
Shows ingredients/products
Includes crafting time
Returns
Recipe
object
Example:
# Get recipe for electronic circuits
recipe
=
get_prototype_recipe
(
Prototype
.
ElectronicCircuit
)
print
(
f
"Ingredients:
{
recipe
.
ingredients
}
"
)
print
(
f
"Crafting time:
{
recipe
.
energy
}
"
)
set_entity_recipe

Configures machine crafting recipes.
Features:
Works with assemblers/chemical plants
Validates recipe requirements
Returns updated entity
Example:
# Set an assembling machine to craft iron gear wheels
assembler
=
get_entity
(
Prototype
.
AssemblingMachine1
,
position
)
set_entity_recipe
(
assembler
,
Prototype
.
IronGearWheel
)
set_research

Initiates technology research.
Features:
Validates prerequisites
Returns required ingredients
Handles research queue
Example:
# Start researching automation
research
=
set_research
(
Technology
.
Automation
)
get_research_progress

Monitors research status.
Features:
Shows remaining requirements
Tracks progress percentage
Returns ingredient list
Example:
# Check research progress
progress
=
get_research_progress
()
print
(
f
"Current research:
{
progress
.
name
}
"
)
print
(
f
"Progress:
{
progress
.
level
}
%"
)
Movement & Utility

move_to

Moves player to position.
Features:
Pathfinds around obstacles
Can place items while moving
Returns final position
Example:
# Move to iron ore patch
iron_position
=
nearest
(
Resource
.
IronOre
)
move_to
(
iron_position
)
nearest_buildable

Finds valid building locations.
Features:
Respects entity dimensions
Handles resource requirements
Returns buildable position
Example:
# Find a buildable position near iron ore
buildable_pos
=
nearest_buildable
(
resource
=
Resource
.
IronOre
,
entity
=
Prototype
.
BurnerMiningDrill
)
sleep

Pauses execution.
Features:
Waits for actions to complete
Adapts to game speed
Maximum 15 second duration
Example:
# Wait for 5 seconds for production to occur
sleep
(
5
)
# Check drill status after waiting
drill
=
get_entity
(
Prototype
.
BurnerMiningDrill
,
drill_position
)
print
(
f
"Drill status:
{
drill
.
status
}
"
)
launch_rocket

Controls rocket silo launches.
Features:
Validates launch requirements
Handles launch sequence
Returns updated silo state
Example:
# Launch a rocket
silo
=
get_entity
(
Prototype
.
RocketSilo
,
silo_position
)
launch_rocket
(
silo
)
Output

print

Outputs debug information to stdout.
Features:
Supports various object types
Useful for monitoring state
Returns formatted string
Example:
# Print entity information
drill
=
get_entity
(
Prototype
.
BurnerMiningDrill
,
position
)
print
(
f
"Drill:
{
drill
}
"
)
print
(
f
"Status:
{
drill
.
status
}
"
)
print
(
f
"Position:
{
drill
.
position
}
"
)
# Print inventory
inventory
=
inspect_inventory
()
print
(
f
"Inventory:
{
inventory
}
"
)
Best Practices

Store Results
: Save tool results as variables for later reference
my_drill
=
place_entity
(
...
)
# Later...
print
(
my_drill
.
status
)
Check Status
: Verify entity status after operations
drill
=
place_entity
(
...
)
sleep
(
5
)
assert
drill
.
status
==
EntityStatus
.
WORKING
Handle Errors
: Use try-except for error handling
try
:
drill
=
place_entity
(
...
)
except
InvalidEntityPlacementException
as
e
:
print
(
f
"Placement failed:
{
e
}
"
)
Print for Debugging
: Use
print()
to observe state
print
(
f
"Entities:
{
get_entities
()
}
"
)
print
(
f
"Inventory:
{
inspect_inventory
()
}
"
)
Wait for Actions
: Use
sleep()
to allow time for completion
place_entity
(
...
)
sleep
(
10
)
# Wait for production
Next Steps

Learn how to
Creating Custom Tools
for specialized functionality
Review
Tools Overview
for architectural details
See
Quickstart
for usage examples

================================================================================
Creating Custom Tools — Factorio Learning Environment 0.3.0 documentation
https://jackhopkins.github.io/factorio-learning-environment/sphinx/build/html/tools/custom_tools.html
================================================================================

Creating Custom Tools

This guide explains how to create custom tools for FLE to extend agent capabilities with specialized functionality.
Overview

A custom tool requires three components:
agent.md
: Documentation for the agent
client.py
: Python interface
server.lua
: Lua implementation
Tool Structure

Tools live in
fle/env/tools/
:
fle/env/tools/
├── admin/          # Non-agent accessible tools
└── agent/          # Agent-accessible tools
    └── my_tool/    # Your custom tool
        ├── agent.md
        ├── client.py
        └── server.lua
Step-by-Step Guide

Step 1: Create Tool Directory

Create a new directory in
fle/env/tools/agent/
:
mkdir
fle/env/tools/agent/my_tool
Step 2: Create client.py

Create
client.py
with a class inheriting from
Tool
:
from
typing
import
Optional
from
fle.env.tools.tool
import
Tool
from
fle.env.entities
import
Entity
from
fle.env.models
import
Position
class
MyTool
(
Tool
):
"""
Brief description of what your tool does.
"""
def
__call__
(
self
,
entity
:
Entity
,
target_position
:
Position
,
quantity
:
Optional
[
int
]
=
None
)
->
dict
:
"""
Detailed description of the tool's functionality.
Args:
entity: The entity to operate on
target_position: Where to perform the action
quantity: Optional quantity parameter
Returns:
Dictionary containing result information
Raises:
InvalidParameterException: If parameters are invalid
EntityNotFoundException: If entity doesn't exist
"""
# Call server-side implementation
result
=
self
.
execute
(
entity
=
entity
.
name
,
position
=
target_position
.
to_dict
(),
quantity
=
quantity
)
return
result
Key Requirements:
Inherit from
Tool
Implement
__call__
method
Use type annotations
Call
self.execute()
to invoke server-side logic
Document parameters, return values, and exceptions
Step 3: Create server.lua

Create
server.lua
with the game logic:
-- Register the tool action
global
.
actions
.
my_tool
=
function
(
params
)
-- Extract parameters
local
entity_name
=
params
.
entity
local
position
=
params
.
position
local
quantity
=
params
.
quantity
or
1
-- Validate parameters
if
not
entity_name
or
not
position
then
return
{
success
=
false
,
error
=
"Missing required parameters"
}
end
-- Find the entity
local
entity
=
game
.
surfaces
[
1
].
find_entity
(
entity_name
,
position
)
if
not
entity
then
return
{
success
=
false
,
error
=
"Entity not found at position"
}
end
-- Perform the action using Factorio API
local
result
=
entity
.
some_action
(
quantity
)
-- Return serialized result
return
{
success
=
true
,
entity
=
serialize_entity
(
entity
),
result
=
result
}
end
Key Requirements:
Register function in
global.actions
Validate all parameters
Use
Factorio API
Return a serializable table
Include error handling
Step 4: Create agent.md

Create
agent.md
with agent-facing documentation:
# My Tool
## Description
Brief description of what the tool does and when to use it.
## Usage
```python
result
=
my_tool
(
entity
=
my_entity
,
target_position
=
Position
(
x
=
10
,
y
=
20
),
quantity
=
5
)
```
## Parameters
-
`entity`
(Entity): The entity to operate on
-
`target_position`
(Position): Where to perform the action
-
`quantity`
(int, optional): How many items to process. Defaults to 1.
## Returns
Dictionary containing:
-
`success`
(bool): Whether the operation succeeded
-
`entity`
(Entity): Updated entity object
-
`result`
: Operation-specific result data
## Best Practices
1.
Always check entity status before calling
2.
Use reasonable quantity values
3.
Verify results with assertions
## Common Pitfalls
-
Entity must exist at the specified position
-
Target position must be valid
-
Quantity cannot exceed inventory limits
## Examples
### Basic Usage
```python
entity
=
get_entity
(
Prototype
.
Chest
,
Position
(
x
=
0
,
y
=
0
))
result
=
my_tool
(
entity
,
Position
(
x
=
5
,
y
=
5
),
quantity
=
10
)
assert
result
[
'success'
]
```
### Error Handling
```python
try
:
result
=
my_tool
(
entity
,
position
)
except
InvalidParameterException
as
e
:
print
(
f
"Invalid parameters:
{
e
}
"
)
```
Step 5: Test Your Tool

Create a test in
fle/env/tests/actions/
:
import
pytest
from
fle.env.gym_env
import
FactorioGymEnv
from
fle.env.models
import
Position
def
test_my_tool
():
env
=
FactorioGymEnv
()
obs
=
env
.
reset
()
# Setup test scenario
code
=
"""
entity = place_entity(
Prototype.Chest,
Position(x=0, y=0),
Direction.NORTH
)
# Test your tool
result = my_tool(
entity=entity,
target_position=Position(x=5, y=5),
quantity=10
)
print(result)
assert result['success']
"""
action
=
Action
(
agent_idx
=
0
,
code
=
code
)
obs
,
reward
,
done
,
truncated
,
info
=
env
.
step
(
action
)
# Verify results
assert
"success"
in
obs
[
'raw_text'
]
env
.
close
()
Complete Example

Here’s a complete example of a tool that transfers items between two chests:
client.py:
from
typing
import
Optional
from
fle.env.tools.tool
import
Tool
from
fle.env.entities
import
Entity
class
TransferItems
(
Tool
):
"""Transfers items between two entities."""
def
__call__
(
self
,
source
:
Entity
,
destination
:
Entity
,
item
:
str
,
quantity
:
int
)
->
dict
:
"""
Transfer items from source to destination.
Args:
source: Entity to take items from
destination: Entity to place items into
item: Item prototype name
quantity: Number of items to transfer
Returns:
Dictionary with transfer results
Raises:
InsufficientItemsException: Not enough items in source
InventoryFullException: Destination inventory is full
"""
result
=
self
.
execute
(
source
=
source
.
name
,
source_position
=
source
.
position
.
to_dict
(),
destination
=
destination
.
name
,
destination_position
=
destination
.
position
.
to_dict
(),
item
=
item
,
quantity
=
quantity
)
return
result
server.lua:
global
.
actions
.
transfer_items
=
function
(
params
)
local
source
=
game
.
surfaces
[
1
].
find_entity
(
params
.
source
,
params
.
source_position
)
local
destination
=
game
.
surfaces
[
1
].
find_entity
(
params
.
destination
,
params
.
destination_position
)
if
not
source
or
not
destination
then
return
{
success
=
false
,
error
=
"Entity not found"
}
end
-- Get source inventory
local
source_inv
=
source
.
get_inventory
(
defines
.
inventory
.
chest
)
if
not
source_inv
then
return
{
success
=
false
,
error
=
"No source inventory"
}
end
-- Check if enough items
local
available
=
source_inv
.
get_item_count
(
params
.
item
)
if
available
<
params
.
quantity
then
return
{
success
=
false
,
error
=
"Insufficient items"
,
available
=
available
}
end
-- Transfer items
local
removed
=
source_inv
.
remove
({
name
=
params
.
item
,
count
=
params
.
quantity
})
local
dest_inv
=
destination
.
get_inventory
(
defines
.
inventory
.
chest
)
local
inserted
=
dest_inv
.
insert
({
name
=
params
.
item
,
count
=
removed
})
-- Return any excess
if
inserted
<
removed
then
source_inv
.
insert
({
name
=
params
.
item
,
count
=
removed
-
inserted
})
end
return
{
success
=
true
,
transferred
=
inserted
,
source
=
serialize_entity
(
source
),
destination
=
serialize_entity
(
destination
)
}
end
agent.md:
# Transfer Items
Transfer items between two entities' inventories.
## Usage
```python
source_chest
=
get_entity
(
Prototype
.
IronChest
,
Position
(
x
=
0
,
y
=
0
))
dest_chest
=
get_entity
(
Prototype
.
IronChest
,
Position
(
x
=
5
,
y
=
5
))
result
=
transfer_items
(
source
=
source_chest
,
destination
=
dest_chest
,
item
=
'iron-plate'
,
quantity
=
50
)
```
## Best Practices
1.
Check source has enough items before transferring
2.
Verify destination has space
3.
Handle partial transfers gracefully
Automatic Registration

Once your tool is created, it will be automatically:
Discovered by the environment
Available to agents in the Python namespace
Documented in agent context with the
agent.md
content
No additional registration steps are needed!
Tips & Best Practices

Keep It Simple
: Tools should do one thing well
Validate Early
: Check parameters in both client and server
Document Thoroughly
: Agents rely on good documentation
Handle Errors
: Provide clear error messages
Test Extensively
: Create comprehensive test cases
Use Type Hints
: Make the interface clear with Python type annotations
Serialize Carefully
: Ensure all return values are JSON-serializable
Common Patterns

Querying Entity State

local
entity
=
game
.
surfaces
[
1
].
find_entity
(
name
,
position
)
return
serialize_entity
(
entity
)
Modifying Inventory

local
inventory
=
entity
.
get_inventory
(
defines
.
inventory
.
chest
)
inventory
.
insert
({
name
=
item
,
count
=
quantity
})
Moving Entities

local
success
=
entity
.
teleport
(
new_position
)
Checking Validity

if
not
entity
.
valid
then
return
{
success
=
false
,
error
=
"Entity no longer exists"
}
end
Next Steps

Review
Core Tools Reference
for implementation patterns
See
Tools Overview
for architecture details
Check the
Factorio Lua API
Join the
Discord
for help

================================================================================
Model Context Protocol (MCP) — Factorio Learning Environment 0.3.0 documentation
https://jackhopkins.github.io/factorio-learning-environment/sphinx/build/html/advanced/mcp.html
================================================================================

Model Context Protocol (MCP)

FLE supports the
Model Context Protocol
(MCP) to enable LLM reasoning models to invoke tools directly.
Overview

The Model Context Protocol is a standardized interface that allows AI models to interact with external tools and services. FLE’s MCP integration enables:
Direct tool invocation from LLM reasoning models
Standardized request/response formats
Seamless integration with MCP-compatible clients
What is MCP?

MCP provides a universal interface for:
Tool Discovery
: Models can discover available tools and their capabilities
Tool Invocation
: Models can call tools with structured parameters
Result Handling
: Models receive typed responses from tool calls
Benefits

Using MCP with FLE provides:
Standardization
: Works with any MCP-compatible client
Type Safety
: Structured tool definitions with parameter types
Extensibility
: Easy to add new tools to the MCP interface
Interoperability
: Compatible with the broader MCP ecosystem
Installation

To use MCP features, install FLE with MCP support:
pip
install
factorio-learning-environment
[
mcp
]
# Or with uv
uv
add
factorio-learning-environment
[
mcp
]
Configuration

MCP configuration is located in
fle/env/protocols/_mcp/
. The MCP server automatically exposes all agent-accessible tools.
Using MCP

Starting the MCP Server

The MCP server can be started alongside the FLE environment:
from
fle.env.protocols.mcp
import
MCPServer
# Initialize MCP server
server
=
MCPServer
()
server
.
start
()
Tool Discovery

MCP clients can discover available tools:
# List all available tools
tools
=
server
.
list_tools
()
for
tool
in
tools
:
print
(
f
"Tool:
{
tool
.
name
}
"
)
print
(
f
"Description:
{
tool
.
description
}
"
)
print
(
f
"Parameters:
{
tool
.
parameters
}
"
)
Invoking Tools

Tools can be invoked through the MCP interface:
# Invoke a tool
result
=
server
.
invoke_tool
(
tool_name
=
"place_entity"
,
parameters
=
{
"entity"
:
"burner-mining-drill"
,
"position"
:
{
"x"
:
10
,
"y"
:
20
},
"direction"
:
"north"
}
)
print
(
f
"Result:
{
result
}
"
)
Integration with LLM Clients

MCP-Compatible Clients

FLE’s MCP implementation works with:
Claude Desktop
Other MCP-compatible AI assistants
Custom MCP clients
Example Integration

Here’s how to integrate FLE with an MCP-compatible client:
{
"mcpServers"
:
{
"factorio"
:
{
"command"
:
"python"
,
"args"
:
[
"-m"
,
"fle.env.protocols.mcp.server"
],
"env"
:
{
"FLE_CLUSTER_HOST"
:
"localhost"
,
"FLE_CLUSTER_PORT"
:
"34197"
}
}
}
}
Tool Definitions

MCP tools are automatically generated from FLE’s tool definitions. Each tool includes:
Name
: The tool identifier
Description
: What the tool does (from
agent.md
)
Parameters
: Typed parameter schema
Return Type
: Expected response format
Example Tool Definition

{
"name"
:
"place_entity"
,
"description"
:
"Places an entity in the world at a specified position"
,
"parameters"
:
{
"type"
:
"object"
,
"properties"
:
{
"entity"
:
{
"type"
:
"string"
,
"description"
:
"The entity prototype to place"
},
"position"
:
{
"type"
:
"object"
,
"properties"
:
{
"x"
:
{
"type"
:
"number"
},
"y"
:
{
"type"
:
"number"
}
}
},
"direction"
:
{
"type"
:
"string"
,
"enum"
:
[
"north"
,
"south"
,
"east"
,
"west"
]
}
},
"required"
:
[
"entity"
,
"position"
]
}
}
Advanced Usage

Custom MCP Tools

You can create custom MCP-specific tools by following the
Creating Custom Tools
guide. Tools created this way are automatically exposed via MCP.
Error Handling

MCP calls return structured errors:
{
"error"
:
{
"code"
:
"InvalidParameters"
,
"message"
:
"Entity 'invalid-entity' not found"
,
"details"
:
{
"entity"
:
"invalid-entity"
,
"available_entities"
:
[
"burner-mining-drill"
,
"iron-chest"
,
...
]
}
}
}
State Management

MCP maintains state between tool calls:
Variables persist in the namespace
Entities remain referenced across calls
Game state is preserved
Architecture

┌─────────────────────┐
│   MCP Client        │
│  (Claude, etc.)     │
└──────────┬──────────┘
           │
           │ MCP Protocol
           │
┌──────────▼──────────┐
│   MCP Server        │
│  (FLE Protocol)     │
└──────────┬──────────┘
           │
           │ Tool Calls
           │
┌──────────▼──────────┐
│   FLE Environment   │
│  (Game Instance)    │
└─────────────────────┘
Documentation

For detailed MCP documentation, see:
Official MCP Documentation
fle/env/protocols/_mcp/README.md
in the repository
Troubleshooting

Connection Issues

If MCP clients can’t connect:
Verify the MCP server is running
Check port configuration
Ensure Factorio cluster is started
Tool Not Found

If a tool is not available via MCP:
Verify the tool exists in
fle/env/tools/agent/
Check that the tool has all required files (
client.py
,
server.lua
,
agent.md
)
Restart the MCP server
Invalid Parameters

If tool calls fail with parameter errors:
Check the tool’s parameter schema
Verify parameter types match the schema
Ensure required parameters are provided
Next Steps

Review
Tools Overview
to understand available tools
See
Creating Custom Tools
to create MCP-compatible tools
Check the official MCP documentation for client integration

================================================================================
Sprites — Factorio Learning Environment 0.3.0 documentation
https://jackhopkins.github.io/factorio-learning-environment/sphinx/build/html/advanced/sprites.html
================================================================================

Sprites

FLE includes sprite management functionality for downloading spritemaps, extracting individual entity sprites, icons, and other visual assets from HuggingFace for use in visual reasoning tasks.
Overview

The sprite system provides:
Sprite Downloads
: Automatic downloading of Factorio sprite assets
Extraction
: Processing spritemaps into individual entity sprites
Icons
: Entity and item icons for visual identification
Visual Reasoning
: Support for vision-enabled agents
Why Use Sprites?

Sprites enable visual reasoning capabilities for agents:
Visual Observations
: Agents can see the game state as images
Entity Recognition
: Identify entities by their visual appearance
Spatial Reasoning
: Understand layouts and positioning visually
Multimodal Learning
: Combine text and visual information
Installation

Sprites are automatically downloaded when needed, but you can pre-download them:
# Download and generate sprites
fle
sprites
# Force re-download even if sprites exist
fle
sprites
--force
# Use custom directories and worker count
fle
sprites
--spritemap-dir
.fle/spritemaps
--sprite-dir
.fle/sprites
--workers
5
Default Locations

By default, sprites are stored in:
Spritemaps
:
.fle/spritemaps/
- Raw spritemap files from HuggingFace
Sprites
:
.fle/sprites/
- Extracted individual entity/item sprites
You can customize these locations using command-line arguments.
CLI Usage

Basic Command

# Download and extract sprites
fle
sprites
Options

# Force re-download
fle
sprites
--force
# Custom directories
fle
sprites
--spritemap-dir
/path/to/spritemaps
--sprite-dir
/path/to/sprites
# Parallel processing (default: 4 workers)
fle
sprites
--workers
8
Programmatic Usage

Loading Sprites

from
fle.env.sprites
import
SpriteManager
# Initialize sprite manager
sprite_manager
=
SpriteManager
()
# Get sprite for an entity
sprite
=
sprite_manager
.
get_sprite
(
'burner-mining-drill'
)
# Get icon for an item
icon
=
sprite_manager
.
get_icon
(
'iron-plate'
)
# Get all available sprites
available
=
sprite_manager
.
list_sprites
()
Using Sprites with Agents

from
fle.agents
import
VisualAgent
import
gym
# Create environment with visual observations
env
=
gym
.
make
(
"iron_ore_throughput"
)
# Create visual agent
agent
=
VisualAgent
(
sprite_manager
=
SpriteManager
(),
model
=
"gpt-4-vision"
)
# Agent can now use visual information
obs
=
env
.
reset
()
action
=
agent
.
get_action
(
obs
,
include_visual
=
True
)
Visual Observations

Visual observations include:
Map Image
: Base64 encoded PNG of the game map
Entity Sprites
: Individual entity appearances
Overlays
: Visual indicators for status, connections, etc.
Example observation with visuals:
{
'raw_text'
:
'...'
,
'entities'
:
[
...
],
'map_image'
:
'data:image/png;base64,...'
,
'sprites'
:
{
'burner-mining-drill'
:
'data:image/png;base64,...'
,
'iron-chest'
:
'data:image/png;base64,...'
}
}
Sprite Categories

Entity Sprites

Visual representations of game entities:
Mining drills
Furnaces
Assembling machines
Inserters
Transport belts
Pipes
Power poles
Item Icons

Icons for items and resources:
Raw materials (ore, wood, stone)
Plates (iron, copper, steel)
Intermediate products
Science packs
Modules
Performance Considerations

Sprite Loading

Sprites are loaded on-demand by default
Pre-loading all sprites increases memory usage but improves performance
Use worker processes for faster initial extraction
Caching

Extracted sprites are cached on disk
Subsequent loads are much faster
Clear cache with
fle
sprites
--force
Resolution

Sprites are provided at their native resolution. You can resize them as needed:
from
PIL
import
Image
import
base64
from
io
import
BytesIO
# Decode base64 sprite
sprite_data
=
base64
.
b64decode
(
sprite_base64
)
image
=
Image
.
open
(
BytesIO
(
sprite_data
))
# Resize
resized
=
image
.
resize
((
32
,
32
))
Advanced Usage

Custom Sprite Sources

You can provide custom sprite sources:
sprite_manager
=
SpriteManager
(
spritemap_dir
=
'/custom/path/spritemaps'
,
sprite_dir
=
'/custom/path/sprites'
)
Batch Processing

Process multiple sprites efficiently:
# Get multiple sprites at once
sprites
=
sprite_manager
.
get_sprites
([
'burner-mining-drill'
,
'iron-chest'
,
'stone-furnace'
])
Export Sprites

Export sprites to individual files:
# Export all sprites to directory
fle
sprites
--export-dir
./exported_sprites
Integration with Vision Models

GPT-4 Vision

import
openai
import
base64
# Get map image
map_image
=
obs
[
'map_image'
]
# Send to GPT-4 Vision
response
=
openai
.
ChatCompletion
.
create
(
model
=
"gpt-4-vision-preview"
,
messages
=
[
{
"role"
:
"user"
,
"content"
:
[
{
"type"
:
"text"
,
"text"
:
"Analyze this Factorio base layout:"
},
{
"type"
:
"image_url"
,
"image_url"
:
{
"url"
:
map_image
}}
]
}
]
)
Claude Vision

import
anthropic
client
=
anthropic
.
Anthropic
()
# Get map image (remove data URL prefix)
map_image_data
=
obs
[
'map_image'
]
.
split
(
','
)[
1
]
message
=
client
.
messages
.
create
(
model
=
"claude-3-opus-20240229"
,
messages
=
[
{
"role"
:
"user"
,
"content"
:
[
{
"type"
:
"image"
,
"source"
:
{
"type"
:
"base64"
,
"media_type"
:
"image/png"
,
"data"
:
map_image_data
}
},
{
"type"
:
"text"
,
"text"
:
"What entities do you see in this layout?"
}
]
}
]
)
Troubleshooting

Download Fails

If sprite download fails:
Check your internet connection
Verify access to HuggingFace
Try again with
--force
flag
Missing Sprites

If specific sprites are missing:
Run
fle
sprites
--force
to re-download
Check the sprite directory exists
Verify sprite names match Factorio prototypes
Memory Issues

If you encounter memory issues:
Don’t pre-load all sprites
Use on-demand loading
Clear sprite cache periodically
Image Format Issues

If image decoding fails:
Verify base64 encoding is correct
Check image format (should be PNG)
Ensure data URL prefix is handled correctly
Next Steps

Learn about
Tools Overview
for non-visual interactions
See the
Visual Agent example
Review
Environment Overview
for context

================================================================================
Database Configuration — Factorio Learning Environment 0.3.0 documentation
https://jackhopkins.github.io/factorio-learning-environment/sphinx/build/html/advanced/database.html
================================================================================

Database Configuration

FLE supports database checkpointing for long-running trajectories. The database stores agent outputs, environment feedback, game states, and histories of trajectories.
Overview

The database system enables:
Checkpointing
: Save game state at every agent step
Resume Capability
: Continue trajectories from any checkpoint
Trajectory History
: Track complete agent interaction history
Analytics
: Analyze agent behavior across runs
Supported Databases

FLE supports two database backends out of the box:
SQLite
(Default): File-based, zero-configuration
PostgreSQL
: Client-server, better for concurrent access
SQLite Configuration

SQLite is the default database and requires minimal configuration.
Setup

Set the database type in
.env
:
FLE_DB_TYPE
=
"sqlite"
Configure the database file location:
SQLITE_DB_FILE
=
".fle/data.db"
The SQLite file will be created automatically in the specified location if it doesn’t exist.
Benefits

Zero Setup
: No server required
Portable
: Single file contains all data
Simple
: Easy to backup and share
Limitations

Not suitable for concurrent writes
Limited scalability for very large datasets
Single-threaded access
PostgreSQL Configuration

PostgreSQL provides better performance for large-scale experiments and concurrent access.
Setup with Docker

The easiest way to set up PostgreSQL is using Docker:
docker
run
--name
fle-postgres
\
-e
POSTGRES_PASSWORD
=
fle123
\
-e
POSTGRES_USER
=
fle_user
\
-e
POSTGRES_DB
=
fle_database
\
-p
5432
:5432
\
-d
postgres:15
Environment Variables

Configure PostgreSQL in your
.env
file:
# Database Configuration - Set to postgres to use PostgreSQL
FLE_DB_TYPE
=
"postgres"
# PostgreSQL Configuration
SKILLS_DB_HOST
=
localhost
SKILLS_DB_PORT
=
5432
SKILLS_DB_NAME
=
fle_database
SKILLS_DB_USER
=
fle_user
SKILLS_DB_PASSWORD
=
fle123
Manual PostgreSQL Setup

If you prefer to install PostgreSQL manually:
Install PostgreSQL 15+
Create a database:
CREATE
DATABASE
fle_database
;
CREATE
USER
fle_user
WITH
PASSWORD
'fle123'
;
GRANT
ALL
PRIVILEGES
ON
DATABASE
fle_database
TO
fle_user
;
Update
.env
with your connection details
Benefits

Concurrent Access
: Multiple processes can write simultaneously
Scalability
: Handles large datasets efficiently
Advanced Features
: Better query optimization, indexes, etc.
Limitations

Requires server setup and management
More complex configuration
Network dependency
Database Schema

The FLE database stores:
Trajectories

id
: Unique trajectory identifier
task_id
: Associated task
start_time
: When trajectory began
end_time
: When trajectory completed
status
: Current status (running, completed, failed)
Steps

id
: Unique step identifier
trajectory_id
: Parent trajectory
step_number
: Sequential step number
agent_code
: Code executed by agent
environment_feedback
: Response from environment
game_state
: Serialized game state
timestamp
: When step occurred
Game States

id
: Unique state identifier
trajectory_id
: Associated trajectory
step_id
: Associated step
state_data
: Serialized game state
timestamp
: When state was captured
Using the Database

Accessing the Database

from
fle.commons.db_client
import
get_db_client
# Get database client (auto-detects type from .env)
db
=
get_db_client
()
# Query trajectories
trajectories
=
db
.
get_all_trajectories
()
# Get specific trajectory
trajectory
=
db
.
get_trajectory
(
trajectory_id
)
# Get steps for a trajectory
steps
=
db
.
get_trajectory_steps
(
trajectory_id
)
Saving Checkpoints

# Save a checkpoint
db
.
save_checkpoint
(
trajectory_id
=
trajectory_id
,
step_number
=
step_num
,
agent_code
=
code
,
environment_feedback
=
feedback
,
game_state
=
state
)
Resuming from Checkpoint

# Load checkpoint
checkpoint
=
db
.
get_checkpoint
(
trajectory_id
,
step_number
)
# Resume environment from checkpoint
env
.
load_state
(
checkpoint
[
'game_state'
])
# Continue execution
obs
,
reward
,
done
,
truncated
,
info
=
env
.
step
(
next_action
)
Database Client API

Core Methods

# Create new trajectory
trajectory_id
=
db
.
create_trajectory
(
task_id
,
metadata
)
# Save step
db
.
save_step
(
trajectory_id
,
step_data
)
# Get trajectory
trajectory
=
db
.
get_trajectory
(
trajectory_id
)
# Get all trajectories for a task
trajectories
=
db
.
get_task_trajectories
(
task_id
)
# Delete trajectory
db
.
delete_trajectory
(
trajectory_id
)
Query Methods

# Get latest checkpoint
checkpoint
=
db
.
get_latest_checkpoint
(
trajectory_id
)
# Get checkpoint at specific step
checkpoint
=
db
.
get_checkpoint
(
trajectory_id
,
step_number
)
# Count steps in trajectory
count
=
db
.
count_steps
(
trajectory_id
)
# Check if trajectory exists
exists
=
db
.
trajectory_exists
(
trajectory_id
)
Migration

Switching Databases

To migrate from SQLite to PostgreSQL:
Export data from SQLite:
from
fle.commons.db_client
import
SQLiteClient
sqlite_db
=
SQLiteClient
(
db_file
=
'.fle/data.db'
)
trajectories
=
sqlite_db
.
export_all
()
Import into PostgreSQL:
from
fle.commons.db_client
import
PostgreSQLClient
pg_db
=
PostgreSQLClient
(
host
=
'localhost'
,
port
=
5432
,
database
=
'fle_database'
,
user
=
'fle_user'
,
password
=
'fle123'
)
pg_db
.
import_all
(
trajectories
)
Update
.env
to use PostgreSQL
Backup and Restore

SQLite Backup

# Simple file copy
cp
.fle/data.db
.fle/data.db.backup
# Or use SQLite command
sqlite3
.fle/data.db
".backup '.fle/data.db.backup'"
PostgreSQL Backup

# Dump database
pg_dump
-h
localhost
-U
fle_user
fle_database
>
backup.sql
# Restore database
psql
-h
localhost
-U
fle_user
fle_database
<
backup.sql
Performance Optimization

SQLite Optimization

# Use WAL mode for better concurrency
db
.
execute
(
"PRAGMA journal_mode=WAL"
)
# Increase cache size
db
.
execute
(
"PRAGMA cache_size=-64000"
)
# 64MB
PostgreSQL Optimization

-- Create indexes for common queries
CREATE
INDEX
idx_trajectory_task
ON
trajectories
(
task_id
);
CREATE
INDEX
idx_step_trajectory
ON
steps
(
trajectory_id
);
CREATE
INDEX
idx_step_timestamp
ON
steps
(
timestamp
);
-- Analyze tables
ANALYZE
trajectories
;
ANALYZE
steps
;
Troubleshooting

Connection Errors

SQLite
:
Verify file path exists and is writable
Check file permissions
Ensure parent directory exists
PostgreSQL
:
Verify server is running:
docker
ps
or
systemctl
status
postgresql
Check connection details in
.env
Test connection:
psql
-h
localhost
-U
fle_user
fle_database
Performance Issues

SQLite
:
Enable WAL mode
Increase cache size
Consider switching to PostgreSQL for large datasets
PostgreSQL
:
Add indexes on frequently queried columns
Tune PostgreSQL configuration (
postgresql.conf
)
Monitor query performance with
EXPLAIN
ANALYZE
Disk Space

SQLite
:
# Check database size
du
-h
.fle/data.db
# Vacuum to reclaim space
sqlite3
.fle/data.db
"VACUUM;"
PostgreSQL
:
-- Check database size
SELECT
pg_size_pretty
(
pg_database_size
(
'fle_database'
));
-- Vacuum to reclaim space
VACUUM
ANALYZE
;
Best Practices

Regular Backups
: Back up your database regularly, especially before major experiments
Use PostgreSQL for Large Runs
: For experiments with >1000 steps, use PostgreSQL
Clean Up Old Data
: Periodically remove old trajectories you no longer need
Monitor Disk Space
: Keep an eye on database size, especially with SQLite
Use Transactions
: Batch multiple operations in transactions for better performance
Next Steps

Review
Quickstart
for basic usage
See
Environment Overview
for environment context
Check
Troubleshooting
for common issues

================================================================================
Project Structure — Factorio Learning Environment 0.3.0 documentation
https://jackhopkins.github.io/factorio-learning-environment/sphinx/build/html/project_structure.html
================================================================================

Project Structure

This page provides an overview of the FLE codebase organization.
Directory Layout

factorio-learning-environment/
├── .github/                        # GitHub workflows and CI/CD
├── .fle/                           # Runtime data (saves, scenarios, trajectory logs)
├── docs/                           # Documentation and website
├── examples/                       # Example agent implementations
├── fle/                            # Main codebase
│   ├── agents/                     # Agent implementations
│   ├── cluster/                    # Docker orchestration and scenarios
│   ├── commons/                    # Shared utilities and models
│   ├── configs/                    # Configuration files
│   ├── data/                       # Data files and replays
│   ├── env/                        # Core environment
│   ├── eval/                       # Evaluation framework
│   ├── run.py                      # CLI entry point
│   └── server.py                   # RCON server
├── tests/                          # Test suite
├── .example.env                    # Environment variables template
├── BUILD.md                        # Build instructions
├── CONTRIBUTING.md                 # Contribution guidelines
├── pyproject.toml                  # Python project config
└── uv.lock                         # Dependency lock file
Core Directories

fle/agents/

Agent implementations including:
BasicAgent
: Simple text-based agent
VisualAgent
: Vision-enabled agent
MultiAgent
: Multi-agent coordination
Base classes and interfaces
Key Files:
agent_abc.py
: Abstract base class for agents
models.py
: Agent configuration models
fle/cluster/

Docker orchestration and scenario management:
Factorio server containers
Docker Compose configurations
Scenario definitions
Server management utilities
Key Files:
docker-compose.yml
: Container orchestration
scenarios/
: Pre-built game scenarios
fle/commons/

Shared utilities and models used across the codebase:
Data models (Position, Entity, Inventory, etc.)
Utility functions
Constants and enumerations
Database client interface
Key Files:
models.py
: Core data models
db_client.py
: Database abstraction layer
utils.py
: Helper functions
fle/env/

Core environment implementation:
env/
├── gym_env/                # OpenAI Gym interface
│   ├── action.py           # Action definitions
│   ├── observation.py      # Observation space
│   ├── registry.py         # Environment registry
│   └── gym_env.py          # Main gym environment
├── tools/                  # Agent-accessible tools
│   ├── agent/              # Agent tools
│   └── admin/              # Admin tools
├── protocols/              # Communication protocols
│   ├── _mcp/               # Model Context Protocol
│   └── a2a/                # Agent-to-Agent protocol
├── exceptions/             # Custom exceptions
├── entities.py             # Entity definitions
├── instance.py             # Game instance management
└── namespace.py            # Python namespace management
Key Components:
gym_env/
: Standard gym interface for RL frameworks
tools/
: All agent-callable functions
protocols/
: Communication layer implementations
exceptions/
: Typed exceptions for error handling
fle/eval/

Evaluation framework for running experiments:
eval/
├── algorithms/             # Search algorithms
│   ├── beam_search.py      # Beam search implementation
│   ├── mcts.py             # Monte Carlo Tree Search
│   └── independent.py      # Independent evaluation
├── analysis/               # Analysis tools
├── tasks/                  # Task definitions
│   └── task_definitions/   # JSON task configs
│       ├── lab_play/       # Structured tasks
│       └── open_play/      # Open-ended tasks
├── infra/                  # Infrastructure
│   ├── setup_api_keys.py   # API key configuration
│   └── cluster_manager.py  # Cluster management
└── evaluator.py            # Main evaluation logic
Key Files:
evaluator.py
: Runs agent evaluations
tasks/task_definitions/
: Task configurations
algorithms/
: Search and optimization algorithms
tests/

Comprehensive test suite:
tests/
├── actions/                # Tool tests
├── benchmarks/             # Performance benchmarks
├── functional/             # End-to-end tests
├── gym_env/                # Gym interface tests
└── integration/            # Integration tests
Configuration Files

pyproject.toml

Python project configuration:
Package metadata
Dependencies
Optional feature groups (
[eval]
,
[mcp]
,
[psql]
)
Build system configuration
.env

Environment variables (created from
.example.env
):
API keys (OpenAI, Anthropic, etc.)
Database configuration
Cluster settings
Feature flags
Key Modules

fle/run.py

CLI entry point providing commands:
fle
cluster
start
: Start Factorio cluster
fle
eval
: Run evaluations
fle
sprites
: Manage sprites
fle
init
: Initialize configuration
fle/server.py

RCON server for communicating with Factorio instances:
Handles tool invocations
Manages game state
Executes Lua commands
fle/env/instance.py

Manages individual Factorio game instances:
Instance lifecycle
State management
Connection handling
Resource cleanup
fle/env/namespace.py

Python namespace management for agent code:
Variable storage
Function definitions
Class definitions
Namespace isolation
Data Flow

Agent
  │
  ├─> Synthesizes Python Code
  │
  ▼
Environment (gym_env)
  │
  ├─> Interprets Code
  │
  ├─> Executes Tools (client.py)
  │       │
  │       ├─> Calls server.py (RCON)
  │       │       │
  │       │       ├─> Executes server.lua
  │       │       │       │
  │       │       │       └─> Factorio Engine
  │       │       │
  │       │       └─> Returns Results
  │       │
  │       └─> Returns Typed Objects
  │
  ├─> Updates Namespace
  │
  └─> Returns Observation
        │
        └─> Agent
Important Files

Core Environment

fle/env/gym_env/gym_env.py
: Main gym environment
fle/env/instance.py
: Game instance management
fle/env/namespace.py
: Python namespace handling
Tools System

fle/env/tools/tool.py
: Base tool class
fle/env/tools/agent/**/client.py
: Tool implementations
fle/server.py
: Server-side execution
Registry & Tasks

fle/env/gym_env/registry.py
: Environment registry
fle/eval/tasks/task_definitions/
: Task JSON files
fle/eval/evaluator.py
: Evaluation orchestration
Development Workflow

Adding a New Tool

Create directory:
fle/env/tools/agent/my_tool/
Add
client.py
,
server.lua
,
agent.md
Create test:
tests/actions/test_my_tool.py
Tool is automatically discovered
Adding a New Task

Create JSON file:
fle/eval/tasks/task_definitions/my_task.json
Task is automatically registered
Access via:
gym.make("my_task")
Running Tests

# Run all tests
pytest
tests/
# Run specific test file
pytest
tests/actions/test_place_entity.py
# Run with coverage
pytest
--cov
=
fle
tests/
Building Documentation

cd
docs/sphinx
&&
python
-m
sphinx
-b
html
source
build/html

================================================================================
Index — Factorio Learning Environment 0.3.0 documentation
https://jackhopkins.github.io/factorio-learning-environment/sphinx/build/html/genindex.html
================================================================================

Index

================================================================================
Search — Factorio Learning Environment 0.3.0 documentation
https://jackhopkins.github.io/factorio-learning-environment/sphinx/build/html/search.html
================================================================================

Please activate JavaScript to enable the search functionality.

================================================================================
Welcome to Factorio Learning Environment’s documentation! — Factorio Learning Environment 0.3.0 documentation
https://jackhopkins.github.io/factorio-learning-environment/sphinx/build/html/index.html
================================================================================

Welcome to Factorio Learning Environment’s documentation!

An open source framework for developing and evaluating LLM agents in the game of Factorio.
Getting Started
Installation
Prerequisites
Installation Methods
Client-side Setup (Optional)
API Key Configuration
Initial Setup
Verification
Next Steps
Quickstart
CLI Commands
Basic Usage Example
Understanding the REPL Pattern
Listing Available Environments
Creating Different Environments
Complete Workflow Example
Next Steps
Troubleshooting
Common Issues
Testing Your Installation
Getting Help
Debugging Tips
Environment
Environment Overview
The REPL Pattern
Available Tools
The Namespace
Observations
Error Handling
Custom Functions and Classes
Action Space
Observation Space
Environment Methods
Architecture
Task Types
Next Steps
Gym Environment Registry
Overview
Features
Quick Start
Available Environments
Command-Line Tools
Environment Interface
API Reference
Complete Example
Error Handling
Troubleshooting
Testing
Tools
Tools Overview
What are Tools?
Tool Architecture
Anatomy of a Tool
Tool Categories
Using Tools
Return Values
Error Handling
Next Steps
Core Tools Reference
Inventory Management
Entity Manipulation
Resource Operations
Connections
Crafting & Research
Movement & Utility
Output
Best Practices
Next Steps
Creating Custom Tools
Overview
Tool Structure
Step-by-Step Guide
Complete Example
Automatic Registration
Tips & Best Practices
Common Patterns
Next Steps
Advanced Topics
Model Context Protocol (MCP)
Overview
What is MCP?
Benefits
Installation
Configuration
Using MCP
Integration with LLM Clients
Tool Definitions
Advanced Usage
Architecture
Documentation
Troubleshooting
Next Steps
Sprites
Overview
Why Use Sprites?
Installation
Default Locations
CLI Usage
Programmatic Usage
Visual Observations
Sprite Categories
Performance Considerations
Advanced Usage
Integration with Vision Models
Troubleshooting
Next Steps
Database Configuration
Overview
Supported Databases
SQLite Configuration
PostgreSQL Configuration
Database Schema
Using the Database
Database Client API
Migration
Backup and Restore
Performance Optimization
Troubleshooting
Best Practices
Next Steps
Reference
Project Structure
Indices and tables

Index
Module Index
Search Page

